# -*- fill-column: 76; -*-
#+Title: BTF (Bpf Type Format) notes
#+OPTIONS: ^:nil

The BPF Type Format (BTF) is a [[https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html][really cool feature]] that allows us to
describe data types used in e.g. BPF-maps (both key and value).

The [[https://www.kernel.org/doc/html/latest/bpf/btf.html#bpf-type-format-btf][kernel BTF documentation]] is all about encoding details, and not about
how to use BTF.

This is my notes for trying to understand how to use BTF
*from within the kernel*.  The last part is important, the target audience
of this document are other kernel developers.

* Motivation

Specifically I want to figure out, if we can use BTF to allow for
dynamically extending and changing e.g. the map value type, and still have
the kernel validate the contents.

** Use-case: devmap and cpumap

The practical use-case is extending =devmap= and =cpumap= with a BPF-prog
that is run when an =xdp_frame= is redirected to a entry in the map.

David Ahern have [[https://lore.kernel.org/netdev/20200522010526.14649-1-dsahern@kernel.org/][posted RFC]] on extending =devmap=.

** Reason for dynamic map-value

The reason I want to have the map-value more dynamic (both for =devmap= and
=cpumap=) is to allow extending this later. Adding an XDP-prog to run is
only the first step.

Future extensions that could happen:

 1) Add XDP-prog that see packet(s) when ndo_xdp_xmit fails.

 2) Add overflow-queue object/setup that hold packets on ndo_xdp_xmit fails.

 3) Add TX-queue object/setup that determine TX-queue in ndo_xdp_xmit call.

* Investigate other code

The "bpf_spin_lock" changes does a lot of checks based on BTF.

TODO: Investigate their approach.

** bpf_spin_lock approach

Main introducing commit:
- [[https://git.kernel.org/torvalds/c/d83525ca62cf][d83525ca62cf]] ("bpf: introduce bpf_spin_lock")

The "bpf_spin_lock" approach is significantly more advanced than we
actually need. So, need to figure out what parts we want to leverage.

*** Dynamic offset

A data-type =struct bpf_spin_lock anyname= can be located at any (aligned)
offset in the map value.

See code function =btf_find_spin_lock()= in kernel/bpf/btf.c
 - [[https://elixir.bootlin.com/linux/v5.6.14/ident/btf_find_spin_lock][Search btf_find_spin_lock]]
 - Code: [[https://elixir.bootlin.com/linux/v5.6.14/source/kernel/bpf/btf.c#L2327][btf_find_spin_lock()]]

I think it will be overkill for our use-case, to allow dynamic offset. On
the-other-hand, allowing dynamic offset will make it easier to extend the
value data-type.

Even allowing users to add their own user specific "opaque" info. For our
=devmap= use-case, it could be practical to store the egress MAC or VLAN
address directly in the devmap.

*** Insight: name of struct is important

It is the text string ="bpf_spin_lock"= that is used for identifying the
spinlock. This originates from the BTF info for =struct bpf_spin_lock=. The
variable name that is chosen for the spinlock is not used.


** map_check_btf

The function =map_check_btf()= have an explicit call to
=btf_find_spin_lock=. But more interesting each map can implement it's own
callback =map->ops->map_check_btf()=.

#+begin_src C
static int map_check_btf(struct bpf_map *map, const struct btf *btf,
			 u32 btf_key_id, u32 btf_value_id)
{
 [...]
	if (map->ops->map_check_btf)
		ret = map->ops->map_check_btf(map, btf, key_type, value_type);
}
#+end_src

The =map_create()= calls =map_check_btf()=, *after* =map_alloc()= have
allocated map. Usually =attr->key_size= and =attr->value_size= are used in
the map specific map_alloc (e.g. =cpu_map_alloc()=) to reject creation of
the map, if the key or value size are incorrect.  Depending on how dynamic
we want this, these size checks might need to be relaxed.



* Code ideas

