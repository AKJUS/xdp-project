# -*- fill-column: 76; -*-
#+Title: BTF (Bpf Type Format) notes
#+OPTIONS: ^:nil

The BPF Type Format (BTF) is a [[https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html][really cool feature]] that allows us to
describe data types used in e.g. BPF-maps (both key and value).

The [[https://www.kernel.org/doc/html/latest/bpf/btf.html#bpf-type-format-btf][kernel BTF documentation]] is all about encoding details, and not about
how to use BTF.

This is my notes for trying to understand how to use BTF
*from within the kernel*.  The last part is important, the target audience
of this document are other kernel developers.

* Motivation

Specifically I want to figure out, if we can use BTF to allow for
dynamically extending and changing e.g. the map value type, and still have
the kernel validate the contents.

** Use-case: devmap and cpumap

The practical use-case is extending =devmap= and =cpumap= with a BPF-prog
that is run when an =xdp_frame= is redirected to a entry in the map.

David Ahern have [[https://lore.kernel.org/netdev/20200522010526.14649-1-dsahern@kernel.org/][posted RFC]] on extending =devmap=.

** Reason for dynamic map-value

The reason I want to have the map-value more dynamic (both for =devmap= and
=cpumap=) is to allow extending this later. Adding an XDP-prog to run is
only the first step.

Future extensions that could happen:

 1) Add XDP-prog that see packet(s) when ndo_xdp_xmit fails.

 2) Add overflow-queue object/setup that hold packets on ndo_xdp_xmit fails.

 3) Add TX-queue object/setup that determine TX-queue in ndo_xdp_xmit call.

* Investigate other code

The "bpf_spin_lock" changes does a lot of checks based on BTF.

TODO: Investigate their approach.

** bpf_spin_lock approach

Main introducing commit:
- [[https://git.kernel.org/torvalds/c/d83525ca62cf][d83525ca62cf]] ("bpf: introduce bpf_spin_lock")

The "bpf_spin_lock" approach is significantly more advanced than we
actually need. So, need to figure out what parts we want to leverage.

*** Dynamic offset

A data-type =struct bpf_spin_lock anyname= can be located at any (aligned)
offset in the map value.

See code function =btf_find_spin_lock()= in kernel/bpf/btf.c
 - [[https://elixir.bootlin.com/linux/v5.6.14/ident/btf_find_spin_lock][Search btf_find_spin_lock]]
 - Code: [[https://elixir.bootlin.com/linux/v5.6.14/source/kernel/bpf/btf.c#L2327][btf_find_spin_lock()]]

I think it will be overkill for our use-case, to allow dynamic offset. On
the-other-hand, allowing dynamic offset will make it easier to extend the
value data-type.

Even allowing users to add their own user specific "opaque" info. For our
=devmap= use-case, it could be practical to store the egress MAC or VLAN
address directly in the devmap.

*** Insight: name of struct is important

It is the text string ="bpf_spin_lock"= that is used for identifying the
spinlock. This originates from the BTF info for =struct bpf_spin_lock=. The
variable name that is chosen for the spinlock is not used.


** map_check_btf

The function =map_check_btf()= have an explicit call to
=btf_find_spin_lock=. But more interesting each map can implement it's own
callback =map->ops->map_check_btf()=.

#+begin_src C
static int map_check_btf(struct bpf_map *map, const struct btf *btf,
			 u32 btf_key_id, u32 btf_value_id)
{
 [...]
	if (map->ops->map_check_btf)
		ret = map->ops->map_check_btf(map, btf, key_type, value_type);
}
#+end_src

The =map_create()= calls =map_check_btf()=, *after* =map_alloc()= have
allocated map. Usually =attr->key_size= and =attr->value_size= are used in
the map specific map_alloc (e.g. =cpu_map_alloc()=) to reject creation of
the map, if the key or value size are incorrect.  Depending on how dynamic
we want this, these size checks might need to be relaxed.



*** Maps using map_check_btf

Key =BTF_KIND_INT= validation example in array_map_check_btf().

Other candidates:
 - cgroup_storage_check_btf
 - trie_check_btf



* Experimenting

** What happen: Adding BTF to cpumap

Add BTF description when creating cpumap (=BPF_MAP_TYPE_CPUMAP=), without
modifying kernel. This caused libbpf to fail with these error/warning
message:

#+begin_example
libbpf: Error in bpf_create_map_xattr(cpu_map):ERROR: strerror_r(-524)=22(-524). Retrying without BTF.

libbpf: Error in bpf_create_map_xattr(cpu_map):Invalid argument(-22). Retrying without BTF.
#+end_example

As libbpf retries without BTF info it succeeds anyhow, e.g this is just a
warning. The first error message does look a bit odd and originates from
this code:

#+begin_src C
	map->fd = bpf_create_map_xattr(&create_attr);
	if (map->fd < 0 && (create_attr.btf_key_type_id ||
			    create_attr.btf_value_type_id)) {
		char *cp, errmsg[STRERR_BUFSIZE];
		int err = -errno;

		cp = libbpf_strerror_r(err, errmsg, sizeof(errmsg));
		pr_warn("Error in bpf_create_map_xattr(%s):%s(%d). Retrying without BTF.\n",
			map->name, cp, err);
		create_attr.btf_fd = 0;
		create_attr.btf_key_type_id = 0;
		create_attr.btf_value_type_id = 0;
		map->btf_key_type_id = 0;
		map->btf_value_type_id = 0;
		map->fd = bpf_create_map_xattr(&create_attr);
	}
#+end_src

The strange error message comes when I added a slightly more advanced BTF
struct as value.

#+begin_src C
struct cpu_map_value {
	__u32 qsize;
};

struct {
	__uint(type, BPF_MAP_TYPE_CPUMAP);
	__type(key, u32);
	__type(value, struct cpu_map_value);
	__uint(max_entries, MAX_CPUS);
} cpu_map SEC(".maps");
#+end_src

Trying to debug what kernel function call that returns this error.

The BPF tracepoint were removed in commit 4d220ed0f814 ("bpf: remove
tracepoints from bpf core") (Author: Alexei Starovoitov). This makes it
harder debug and isolate 'map_create' function call (as it get inlined).



#+begin_example
 perf trace record -o /tmp/perf.data -e syscalls:sys_enter_bpf \
  ./xdp_redirect_cpu -F --dev mlx5p1 --q 1024 --cpu 4 --prog xdp_cpu_map0
#+end_example

Finding BPF syscall to ftrace:
#+begin_example
 $ sudo trace-cmd list -f SyS_bpf
 __x64_sys_bpf
 __ia32_sys_bpf
#+end_example

In another terminal record via trace-cmd:
#+begin_example
sudo trace-cmd record -p function_graph -g __x64_sys_bpf
#+end_example
