#+Title: Benchmarking branch "traits-009-bench" via kernel module

Using the prototype-kernel (out-of-tree) time_bench framework for
micro-benchmarking "traits" branch:

 - https://github.com/arthurfabre/linux/commits/afabre/traits-009-bench

And using selftest benchmark.

* Table of Contents                                                     :toc:
- [[#prototype-kernel-benchmarks][Prototype-Kernel benchmarks]]
  - [[#amd-cpu-bench_traits_simple---with-srso][AMD CPU bench_traits_simple - with SRSO]]
- [[#bpf-selftests][BPF selftests]]
  - [[#explaining-our-bench-extension][Explaining our bench extension]]
  - [[#example-variable-results][Example: Variable results]]

* Prototype-Kernel benchmarks

** AMD CPU bench_traits_simple - with SRSO

System:
 - Kernel: 6.14.0-rc3-traits-009-bench+
 - CPU: AMD EPYC 9684X 96-Core

Traits compare table: between 6.13.0-traits-006-skb and this kernel
 - data for 6.13.0-traits-006-skb from [[file:../mem/page_pool08_bench_AMD.org]]

| Test name          | Cycles |     |      | *Nanosec* |        |        |      % |
| branch: traits-NNN |    006 | 009 | diff |       006 |    009 |   diff | change |
|--------------------+--------+-----+------+-----------+--------+--------+--------|
| function_call_cost |     14 |  14 |    0 |     5.702 |  5.703 |   1e-3 |    0.0 |
| func_ptr_call      |     26 |  26 |    0 |    10.335 | 10.329 |  -6e-3 |   -0.1 |
| trait_set          |     22 |  26 |    4 |     8.979 | 10.597 |  1.618 |   18.0 |
| trait_get          |     24 |  24 |    0 |     9.791 |  9.509 | -0.282 |   -2.9 |
#+TBLFM: $4=$3-$2::$7=$6-$5::$8=(($7/$5)*100);%.1f

Raw data:
#+begin_example
 time_bench: Type:for_loop Per elem: 0 cycles(tsc) 0.347 ns (step:0) - (measurement period time:0.034784133 sec time_interval:34784133) - (invoke count:100000000 tsc_interval:88565402)
 time_bench: Type:function_call_cost Per elem: 14 cycles(tsc) 5.703 ns (step:0) - (measurement period time:0.057033614 sec time_interval:57033614) - (invoke count:10000000 tsc_interval:145216023)
 time_bench: Type:func_ptr_call_cost Per elem: 26 cycles(tsc) 10.329 ns (step:0) - (measurement period time:0.103291046 sec time_interval:103291046) - (invoke count:10000000 tsc_interval:262995627)
 time_bench: Type:trait_set Per elem: 26 cycles(tsc) 10.597 ns (step:0) - (measurement period time:0.105978783 sec time_interval:105978783) - (invoke count:10000000 tsc_interval:269838374)
 time_bench: Type:trait_get Per elem: 24 cycles(tsc) 9.509 ns (step:0) - (measurement period time:0.095091553 sec time_interval:95091553) - (invoke count:10000000 tsc_interval:242118165)
#+end_example

* BPF selftests

Under =tools/testing/selftests/bpf/= there is a "bench" program "harness" that
can be extended with benchmarks.

** Explaining our bench extension

Arthur added traits benchmark in commit:
 - https://github.com/arthurfabre/linux/commit/da677f78b98e777e5fc76

The BPF-prog being loaded is:
 - [[https://github.com/arthurfabre/linux/commit/da677f78b98e777e5fc76#diff-b67549a8394fb00ba45ff77d069046c8cab11b29583b8c810595b89b50aa9098R16][tools/testing/selftests/bpf/progs/bench_xdp_traits.c]]

The bench extension program is:
 - [[https://github.com/arthurfabre/linux/commit/da677f78b98e777e5fc76#diff-7c5e2cd8b9a09de765cf10c202c56adf43790d7c707ef064818543dcdfa35ac0][tools/testing/selftests/bpf/benchs/bench_xdp_traits.c]]

The BPF-prog benchmarks are basically doing 10.000 =ITERATIONS= in a for-loop,
running the given traits operation. This is reported as "hits" to the harness.
The BPF program is started via =bpf_prog_test_run_xdp()= (=bpf_test_run=) and
harness will run that for default 7 iterations.

** Example: Variable results

On AMD testlab machine I was surprised to see variation in results:
 - We see operations between 40.970M/s - 63.769M/s

Using =perf stat= when running the results:
#+begin_example
12G:~/git/kernel/arthur/tools/testing/selftests/bpf$
 sudo perf stat ./bench xdp-trait-get

Setting up benchmark 'xdp-trait-get'...
Benchmark 'xdp-trait-get' started.
Iter   0 ( 80.753us): hits   41.597M/s ( 41.597M/prod)
Iter   1 ( -9.643us): hits   40.970M/s ( 40.970M/prod)
Iter   2 (  9.765us): hits   54.769M/s ( 54.769M/prod)
Iter   3 ( 30.728us): hits   62.338M/s ( 62.338M/prod)
Iter   4 ( 14.714us): hits   61.949M/s ( 61.949M/prod)
Iter   5 (-52.588us): hits   63.283M/s ( 63.283M/prod)
Iter   6 ( 20.652us): hits   63.769M/s ( 63.769M/prod)
Summary: throughput   57.847 ± 8.899 M ops/s ( 57.847M ops/prod), latency   17.287 ns/op

 Performance counter stats for './bench xdp-trait-get':

          4,654.91 msec task-clock                       #    0.629 CPUs utilized          
               334      context-switches                 #   71.752 /sec                   
                 1      cpu-migrations                   #    0.215 /sec                   
             3,222      page-faults                      #  692.172 /sec                   
    13,976,805,892      cycles                           #    3.003 GHz                    
     6,616,038,726      stalled-cycles-frontend          #   47.34% frontend cycles idle   
    34,566,485,152      instructions                     #    2.47  insn per cycle         
                                                  #    0.19  stalled cycles per insn
     5,191,797,425      branches                         #    1.115 G/sec                  
       426,294,938      branch-misses                    #    8.21% of all branches        

       7.402855283 seconds time elapsed
#+end_example

There is clear indication that CPU frequency changes are happening.

Notice that CPU were running at 3.003 GHz.
 - Not too bad as base clock is 2.55 GHz
 - But turbo boost allows this CPU to run at 3.7 GHz
   - which is what we expected given our testlab is idle

We are *very* happy to see 2.47 insn per cycle.

Running this again we captured a case where CPU was only running at 2 GHz:
#+begin_example
12G:~/git/kernel/arthur/tools/testing/selftests/bpf$
 sudo perf stat ./bench xdp-trait-get --producers=1

Setting up benchmark 'xdp-trait-get'...
Benchmark 'xdp-trait-get' started.
Iter   0 ( 85.059us): hits   41.416M/s ( 41.416M/prod)
Iter   1 (-21.881us): hits   40.931M/s ( 40.931M/prod)
Iter   2 ( -1.060us): hits   41.240M/s ( 41.240M/prod)
Iter   3 ( 24.778us): hits   42.809M/s ( 42.809M/prod)
Iter   4 ( 84.358us): hits   43.516M/s ( 43.516M/prod)
Iter   5 (-61.491us): hits   43.233M/s ( 43.233M/prod)
Iter   6 (-38.777us): hits   42.892M/s ( 42.892M/prod)
Summary: throughput   42.437 ± 1.082 M ops/s ( 42.437M ops/prod), latency   23.565 ns/op

 Performance counter stats for './bench xdp-trait-get --producers=1':

          5,347.78 msec task-clock                       #    0.721 CPUs utilized          
               265      context-switches                 #   49.553 /sec                   
                 2      cpu-migrations                   #    0.374 /sec                   
             3,224      page-faults                      #  602.867 /sec                   
    10,938,802,987      cycles                           #    2.045 GHz                    
     5,497,305,036      stalled-cycles-frontend          #   50.26% frontend cycles idle   
    26,863,637,718      instructions                     #    2.46  insn per cycle         
                                                  #    0.20  stalled cycles per insn
     4,077,116,526      branches                         #  762.394 M/sec                  
       333,381,343      branch-misses                    #    8.18% of all branches        

       7.420082002 seconds time elapsed
#+end_example
