#+Title: Bigger plan for traits

Benchmarking shows that traits performance is feasible (when tuning side-channel
mitigating modes). This means we can move forward and spend more engineering
resources on making this usable (for our use-cases).

We are not targeting "feature complete" as upstream development is an
evolutionary process, where we learn and take input from others.

We do need to sketch out a bigger plan for traits, as a common vision that
upstream developers can buy into. Introducing something/anything upstream comes
with a future maintenance cost. Without a plan the biggest worry is painting
ourselves into a corner for some of the use-cases we cannot implement in the
first iteration. (Netdev rule of thumb is no more than 15 patches in a
patchset).

Upstream discussions have already started on making the API flexible enough for
handling future changes, but those recommendations have not been fully
implemented yet.

Generally upstream will accept features that are useful on it own. The
compressed Key-Value system that "traits" implement can likely be useful in
other contexts.

Goal: This document need to investigate
 - Layout the bigger plan
 - Make sure our future expansions are doable (no corner painting)
 - Identify unresolved issues
 - Determine the minimum feature set for initial patchset

* Unresolved issues

** Storing bits

Current traits implementation support data lengths 2, 4, 8 bytes.

There are use-cases for storing a single bit (aka "flags").
 - One example is checksum-complete on RX path.

** Access from SKB

We need to extend the SKB (=struct sk_buff=) with information that traits are
available for a given SKB.

** Reserved IDs

The traits proposal blocked Lorenzo's patchset that added fixed struct members
to =xdp_frame=. These members were targeted bridging the gap between XDP and
SKB. Focused on the current HW offload fields in SKB today.

There are multiple places where an =xdp_frame= gets converted into an SKB. In
these places, we are (currently) loosing the NIC hardware offloads (HW-metadata)
as this information isn't available any longer (from RX hardware descriptor).

Transferring these HW offloads via traits, implies that kernel C-code also need
to consume and understand traits.  Upstream proposal is to reserve some IDs for
the kernels usage.

** Update semantics

From an API programmers perspective, will it be useful to have CRUD semantics?
 - C = Create
 - R = Replace
 - U = Update
 - D = Delete

Current patchset provides traits =set=, =get=, =del=.

E.g. can we think of cases where programmer only want to *replace* the value if
something earlier in the call chain has =set= it.

The BPF map API =bpf_map_update_elem= have these =flags=. The man
=bpf-helpers(7)= description says: "Add or update the value of the entry
associated to key in map with value. flags is one of:"

| Flag          | Description                                         |
|---------------+-----------------------------------------------------|
| =BPF_NOEXIST= | The entry for key must not exist in the map.        |
| =BPF_EXIST=   | The entry for key must already exist in the map.    |
| =BPF_ANY=     | No condition on the existence of the entry for key. |
|               |                                                     |

* Registration API

Whether or not to have a registration API deserves it own section.

It would be cool if BPF-progs can store a string as the trait identifier, and
then libbpf will translate this into the trait-ID as BPF load time.

The kernel reserved IDs would also be listed as part of the registration API.
This would make it easy to know what the kernel supports.

Generally a registration API will make it easier to avoid ID collisions. Having
to share global knowledge about IDs for products/services (or teams) requires
coordination. Having the kernel be authoritative will make this easier. We can
likely express/export this via BTF information (/sys/kernel/btf/).

