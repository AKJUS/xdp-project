# -*- fill-column: 79; -*-
#+TITLE: XDP: the Distro View
#+AUTHOR: Jiri Benc, Jesper Dangaard Brouer and Toke Høiland-Jørgensen
#+EMAIL: jbenc@redhat.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: '../reveal.js/js/redhat.js'}
#+REVEAL_ROOT: ../reveal.js
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

This is currently notes for the LinuxPlumbersConf 2019 (LPC) presentation (see
title), and perhaps the slide deck (depending on Jiri Benc's preferences for
formatting tools).

https://www.linuxplumbersconf.org/event/4/contributions/460/

* Abstracts and presentation merge background

The LPC technical committee asked us (Jiri, Jesper and Toke) to merge our talks
into Jiri Benc's more generic XDP talk. Thus, the assignment in this doc it to
perform this merger.  Below is listed the abstracts from the three talks, such
that we can easier merge these.

** Main abstract: XDP the Distro View (Jiri)

Title: XDP: the Distro View
Author: Jiri Benc

It goes without saying that XDP is wanted more and more by everyone. Of course,
the Linux distributions want to bring to users what they want and need. Even
better if it can be delivered in a polished package with as few surprises as
possible: receiving bug reports stemming from users' misunderstanding and from
their wrong expectations does not make good experience neither for the users
nor for the distro developers.

XDP presents interesting challenges to distros: from the initial enablement
(what config options to choose) and security considerations, through user
supportability (packets "mysteriously" disappearing, tcpdump not seeing
everything), through future extension (what happens after XDP is embraced by
different tools, some of those being part of the distro, how that should
interact with users' XDP programs?), to more high level questions, such as user
perception ("how comes my super-important use case cannot be implemented using
XDP?").

Some of those challenges are long solved, some are in progress or have good
workarounds, some of them are yet unsolved. Some of those are solely the
distro's responsibility, some of them need to be addressed upstream. The talk
will present the challenges of enabling XDP in a distro. While it will also
mention the solved ones, its main focus are the problems currently unsolved or
in progress. We'll present some ideas and welcome discussion about possible
solutions using the current infrastructure and about future directions.

** Abstract#2: Improving the XDP User eXperience: via feature detection (Jesper)
Title: Improving the XDP User eXperience: via feature detection
Author: Jesper Dangaard Brouer

The most common asked question is: "Does my NIC support XDP", and our current
answer is read the source code. We really need to come up with a better answer.

The real issue is that users can attach an XDP bpf_prog to a drivers that use
features the driver doesn't implement, which cause silent drops. Or user
doesn't notice, that NIC loading fallback to generic-XDP, which is first
discovered when observing lower performance, or worse not all features are
supported with generic-XDP, resulting in unexpected packet drops.

BPF feature detection, recently added to bpftool, is based on probing the
BPF-core by loading BPF-programs using individual features (notice BPF load
time, not attaching it). Even if your BPF loader doesn't use feature probing,
it will notice if loaded on a incompatible kernel. As an BPF-prog using
something the kernel BPF-core doesn't support will get rejected at load-time,
before you attach the BPF-prog.

This doesn't work for XDP, as features vary on a per driver basis. Currently an
XDP BPF-prog isn't aware of that driver it will get used on, until driver
attach-time. Unfortunately, due to BPF tail-calls, we cannot use the driver
attach-time hook to check for compatibility (given new XDP BPF-progs can be
indirectly "attached" via tail-call map inserts).

In this talk, we will investigate the possibilities of doing XDP feature check
at BPF load-time, by assigning an ifindex to the BPF-prog. The ground work have
already been laid by XDP hardware offload, which already need ifindex at BPF
load-time (to perform BPF byte-code translation into NIC compatible code).

The open question are:
- Can the verifier detect/deduce XDP feature in use, for us?
- How does drivers express/expose XDP features?
- Are features more than XDP return codes, like meta-data support?
- How does this interact with generic-XDP?
- How to expose this to userspace? (to answer does NIC support XDP)
- How to handle tail-call map inserts?

** Abstract#3: Unified semantics for multiple XDP programs on a single interface (Toke)

Title: Unified semantics for multiple XDP programs on a single interface
Author: Toke Høiland-Jørgensen

XDP currently only supports loading a single program on each physical
interface. This is a limitation in cases where multiple functions need to run
on the same interface, for instance a packet filter followed by a forwarding
program. When all programs are written by the same person or group, this can be
solved by cooperative tail-calling between programs, and we have seen several
variations on this scheme already. However, this does not solve the case where
programs written by different people need to cooperate on the same interface,
e.g., if a system administrator wants to use two different third-party software
packages that both offer XDP support. As XDP support becomes more prevalent, we
expect this issue to become more urgent, and so we want to discuss what we can
do to solve this in the upstream community.

As part of this discussion we would like to collect the requirements people
have for chaining programs today. Can we agree on a common set of semantics
that will work for all the current and expected future use cases? Assuming we
can, is it then enough to define a common API for cooperative tail calling
(possibly supported by libbpf), or do we need kernel support to enforce
cooperation?

* Export/generate presentation

** Setup for org export to reveal.js
First, install the ox-reveal emacs package.

Package: ox-reveal git-repo and install instructions:
https://github.com/yjwen/org-reveal

To export hit =C-c C-e R R=, then open .html file to view slideshow.

The variables at document end ("Local Variables") will set up the title slide
and filter the "Slide:" prefix from headings; Emacs will ask for permission to
load them, as they will execute code.

** Export to PDF

The conference requires presentations to be delivered in PDF format.  Usually
the reveal.js when run as a webserver under nodejs, have a printer option for
exporting to PDF vai print to file, but we choose not run this builtin
webserver.

Alternatively I found a tool called 'decktape', for exporting HTML pages to
PDF: https://github.com/astefanutti/decktape

The 'npm install' failed on my system:

 $ npm install decktape

But (after running npm update) I can start the decktape.js file direct via
the 'node' command.

 $ node ~/git/decktape/decktape.js slides.html slides.pdf

This is the command needed on Arch - size is set to get slide text to fit on
the page. -p 100 makes it go faster.

$ decktape -s 1600x900 -p 100 --chrome-arg=--no-sandbox slides.html slides.pdf



* Colors in slides                                                 :noexport:
Text colors on slides are chosen via org-mode italic/bold high-lighting:
 - /italic/ = /green/
 - *bold*   = *yellow*
 - */italic-bold/* = red

* Notes - brainstorm

Unsolved issues:
- eBPF audit
- Safety of verifier
- Controls of eBPF capabilities (like updating maps for unpriv users)
- Multiple XDP programs + debugability
- Feature detection
- Managing expectations for XDP
  - Switching: Cloning
  - Ready-to-run XDP programs

* Slides below                                                     :noexport:

Only sections with tag ":export:" will end-up in the presentation. The prefix
"Slide:" is only syntax-sugar for the reader (and it removed before export by
emacs).

* Slide: Outline                                                     :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

xxx

** Slide: What is XDP?                                              :export:

#+BEGIN_NOTES
People should already know this; but since we already have the slide, might as
well include it.
#+END_NOTES

XDP basically: *New layer in the kernel network stack*
 - Before allocating the SKB
 - Driver level hook at DMA level

Means: Competing at the same “layer” as DPDK / netmap
 - Super fast, due to
   - Take action/decision earlier (e.g. skip some network layers)
   - No memory allocations

/Not kernel bypass/; data-plane is kept inside the kernel
 - Via eBPF: makes early network stack *run-time programmable*
 - Cooperates with the kernel stack

* Notes

** Org-mode hints

https://orgmode.org/manual/Quoting-HTML-tags.html#Quoting-HTML-tags

** Colors from Red Hat guide lines

Red Hat Colors:

 - Red Hat Red #cc0000
 - Medium Red #a30000
 - Dark Red #820000

None of these red colors fit with baggrond color:
 - Using red 65% #ff4d4d
 - Found via: https://www.w3schools.com/colors/colors_picker.asp

Secondary Palette:

 - Dark Blue #004153
 - Medium Blue #4e9fdd
 - Light Blue #5bc6e8
 - Lighter Blue #a3dbe8

Accent Palette:

 - Purple #3b0083
 - Orange #ec7a08
 - Green #7ab800
 - Turquoise #007a87
 - Yellow #fecb00

# Local Variables:
# org-reveal-title-slide: "<h1 class=\"title\">%t</h1><h2
# class=\"author\">Jiri Benc<br/>Jesper Dangaard Brouer<br/>Toke Høiland-Jørgensen</h2>
# <h3>Red Hat inc<br/>Linux Plumbers Conf<br/>Sep 2019</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: " "" contents)))
# End:
