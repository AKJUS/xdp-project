# -*- fill-column: 79; -*-
#+TITLE: BPF/XDP research PhD kickoff: Introduction to BPF/XDP
#+AUTHOR: Jesper Dangaard Brouer <brouer@redhat.com> and Toke Høiland-Jørgensen <toke@redhat.com>
#+EMAIL: brouer@redhat.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: '../reveal.js/js/redhat.js'}
#+REVEAL_ROOT: ../reveal.js
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

This is the slide deck for the PhD Kick-off meeting, 8th September 2020.

* Agenda content                                                   :noexport:

Anna's standard agenda:

1. Welcome and introductions

2. Short introductory presentation from each partner

3. Review of the project plan (overall goals, project structure, research
   tasks)

4. Planning of the first phase of the project (initial research tasks, upcoming
   deliverables, meeting structure)

Specific Content proposed in email thread:

1. Quick recap of the project description, and the background for why we (RH)
   are doing this.

2. "BPF in five minutes" - a quick recap of what this whole BPF subsystem in
   the kernel is and why it's relevant (for both projects, so also focusing on
   tracing). Just to get everyone on the same page, and start people thinking.

3. "Interesting future directions for XDP" - a grab bag of ideas and
   perspectives that we can discuss, and maybe even turn (some of them) into
   starting points for Frey and Simon depending on interest.

   My current list of subjects for this include (to be expanded on
   Tuesday, but in case you want to think about them ahead of time; I
   may also add a few more):

   - How do we define an architecture for a chain of programmable devices /
     device features to cooperate? I.e., how do we combine normal hardware
     offloads, offloaded eBPF/P4, XDP, and the regular kernel stack into a
     coherent whole?

   - How can we realise (in practice) the potential for performance increases
     from dynamic bytecode elimination in eBPF?

   - Using XDP and eBPF in the cloud - there's an ongoing effort to get an
     upstream collaboration going around fixing some of the issues with this
     (see [0])

   - What kind of new performance monitoring tools can we build with eBPF?

* Slide: Outline                                                     :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

Background for Red Hat Research on XDP

BPF in five minutes

Interesting future directions for XDP

* Slide: Basic introduction and understanding of eBPF                :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

/"BPF in five minutes"/

Basic introduction to
- eBPF bytecode
- eBPF concepts: context, maps and helpers
- Compiling restricted-C to eBPF

** Slide: eBPF bytecode                                             :export:

The eBPF bytecode is:
- /Generic Instruction Set/ Architecture (ISA) with C-calling convention
  * Read: the eBPF assembly language
- Designed to *run in the Linux kernel*
  * It is */not a kernel module/*
  * It is a *sandbox* technology; BPF verfier ensures code safety

** Slide: Kernel runtime and hooks                                  :export:

Kernel provides an /eBPF runtime/ environment
- via BPF /maps/ and /helper calls/
- and hook /context/ object

BPF hook point in the Linux kernel have exploded
- XDP and TC-BPF hooks likely *very relevant for this project*
- Many tracepoints, also /all kernel function calls/ via kprobe hooks
- TCP congestion control via BPF hooks
- cgroups, selinux, etc.

** Slide: eBPF concepts: context, maps and helpers

Each eBPF runtime hook gets a *pointer to a context* struct
- BPF bytecode has access to context (read/write limited)
  * verifier may adjust the bytecode for safety

The BPF program itself is stateless
- /Concept eBPF maps/ can be used to create state
- Maps are basically /key = value/ construct

BPF helpers are used for
- calling kernel functions, to obtain info/state from kernel

** Slide: Compiling restricted-C to eBPF into ELF                   :export:

/LLVM compiler/ has an eBPF backend (to */avoid writing eBPF assembly/* by hand)
- Write *Restricted C* -- some limits imposed by sandbox BPF-verfier

Compiler produces an standard ELF "executable" file
- Cannot execute this file directly, as the /eBPF runtime is inside the kernel/
- Need our *own ELF loader* that can:
  * Extract the eBPF bytecode and eBPF maps
  * Do ELF relocation of eBPF maps references in bytecode
  * Create/load eBPF maps and bytecode into kernel
- *Attaching to hook is separate* step

* Emacs tricks

# Local Variables:
# org-re-reveal-title-slide: "<h1 class=\"title\">%t</h1><h2
# class=\"author\">Jesper Dangaard Brouer<br/>Toke Høiland-Jørgensen</h2>
# <h3>Karlstads University (Virtual event)<br/>8th September 2020</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: " "" contents)))
# End:
