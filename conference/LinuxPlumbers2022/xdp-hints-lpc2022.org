# -*- fill-column: 79; -*-
#+TITLE: XDP hints via BPF Type Format (BTF) system
#+AUTHOR: Jesper Dangaard Brouer <hawk@kernel.org>
#+EMAIL: brouer@redhat.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: '../reveal.js/js/redhat.js'}
#+REVEAL_ROOT: ../reveal.js
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

* For conference: Linux Plumbers Conference 2022

[[https://lpc.events/event/16/contributions/1362/][This presentation]] will be given at
[[https://lpc.events/event/16/][LPC 2022]] the Linux Plumbers Conference (LPC).

* Slides below                                                     :noexport:

Only sections with tag ":export:" will end-up in the presentation.

Colors are choosen via org-mode italic/bold high-lighting:
 - /italic/ = /green/
 - *bold*   = *yellow*
 - */italic-bold/* = red

* Slide: What are XDP-hints                                          :export:

/XDP-hints/ dates back to NetDevConf [[https://www.youtube.com/watch?v=uD1_oAHpUmU][Nov 2017]] (by [[https://legacy.netdevconf.info/2.2/papers/waskiewicz-xdpacceleration-talk.pdf][PJ Waskiewicz]])
 - Purpose: Let /XDP/ *access* /HW offload hints/

Basic idea:
 - Provide or extract (from descriptor) NIC hardware offload hints
 - *Store info in XDP metadata area* (located before pkt header)

XDP /metadata area/ avail since [[https://www.spinics.net/lists/netdev/msg456525.html][Sep 2017]] (by Daniel Borkmann)
 - *Space is limited* (currently 32 bytes)

Main reason XDP-hints work *stalled*
 - */No consensus/* on *layout* of XDP metadata
 - /BTF/ was *not ready* at that time

* Slide: What are *traditional* hardware offload hints?              :export:

NIC *hardware* provides offload hints in RX (and TX) *descriptors*
 - */The netstack SKB/* packet data-struct stores+uses these

*RX descriptors* can e.g. provide:
 - RX-/checksum/ validation, RX-/hash/ value, RX-/timestamp/
 - RX-/VLAN/ provides VLAN ID/tag non-inline

*TX descriptors* can e.g. ask hardware to perform actions:
 - *TX*-/checksum/: Ask hardware to compute checksums on transmission
 - TX-/VLAN/: Ask hardware to insert VLAN tag
 - Advanced: /TX-timestamp/ HW stores TX-time and feeds back on completion
 - Advanced: /TX-LaunchTime/ ask HW to send packet at specific time in future

* Slide: XDP-hints layout defined via /BTF layout/                   :export:

My *proposal*: /Use BTF to define the layout of XDP metadata/
 - Each NIC driver can choose its own BTF layout
 - Slightly *challenging requirement*:
   - NIC driver can *change* /layout per pkt/ (e.g timestamp only in PTP pkts)

Open question:
 - /Will BTF be a good fit for this use-case?/

Next slides: Explaining *BTF technical details*

* Slide: Introducing BTF - BPF Type Format                           :export:

*/Assume LPC crowd knows what BTF is/*
 - Slides are here primarily for people downloading these later

[[https://www.kernel.org/doc/html/latest/bpf/btf.html][BTF]] compact Type Format (based on compiler's DWARF debug type info)
 - Great [[https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html][blogpost]] by Andrii Nakryiko
   - 124MB of DWARF data compressed to 1.5MB compact BTF type data
 - Suitable to be /included in Linux kernel image/ by default
   - See file =/sys/kernel/btf/vmlinux= avail in most distro kernels
 - Kernel's runtime data structures have become *self-describing via BTF*

#+begin_src sh
 # bpftool btf dump file /sys/kernel/btf/vmlinux format c
#+end_src

** Slide: More components: CO-RE + BTF + libbpf                     :export:

[[https://nakryiko.com/posts/bpf-portability-and-co-re/#compiler-support][Blogpost]] on BPF *CO-RE* (/Compile Once â€“ Run Everywhere/) (Andrii Nakryiko)
 - Explains how BTF is one piece of the puzzle
 - BPF ELF object files are made /portable across kernel versions via CO-RE/
 - LLVM *compiler emits BTF relocations* (for BPF code accessing struct fields)

BPF-prog (binary ELF object) /loader/ *libbpf* /combines pieces/
 - Tailor BPF-prog code to a particular running kernel
 - Looks at *BPF-prog recorded BTF* type and relocation information
   - /matches/ them to BTF information provided by *running kernel*
   - /updates necessary offsets/ and other relocatable data
 - *Kernel struct can* */change layout/*, iff member /name+size stays/ same

** Slide: [[https://github.com/xdp-project/bpf-examples/blob/master/ktrace-CO-RE/ktrace01_kern.c][Code-Example]]: Partial struct + runtime BTF-id             :export:

BPF-prog can define /partial struct/ with few members
 - libbpf matches + "removes" *triple-underscore* after /real struct name/
 - *preserve_access_index* will be matched against kernel data-structure

#+begin_src C
struct sk_buff___local {
	__u32 hash;
} __attribute__((preserve_access_index));

SEC("kprobe/udp_send_skb.isra.0")
int BPF_KPROBE(udp_send_skb, struct sk_buff___local *skb)
{
	__u32 h; __u32 btf_id;
	BPF_CORE_READ_INTO(&h, skb, hash); /* skb->hash */
	btf_id = bpf_core_type_id_kernel(struct sk_buff___local); /* libbpf load-time lookup */
	bpf_printk("skb->hash=0x%x btf_id(skb)=%d", h, btf_id);
}
#+end_src

Notice: Can get *btf_id* for /sk_buff/ used by *running* /kernel/

** Slide: BTF type IDs and their usage                              :export:

BTF system has *type IDs* to refer to each-other (in compressed format)
 - Zero is not a valid BTF ID and numbering (usually) *starts from one*
   - Userspace can dump and see numbering via /=bpftool btf dump file=/

/Kernel's BTF/ data files are located in *=/sys/kernel/btf/=* (modules since [[https://git.kernel.org/torvalds/c/36e68442d1af][v5.11]])
 - Main file *vmlinux* contains every type /compiled into kernel/
 - All *module files* /offset/ ID numbering to start at *last* /vmlinux/ *ID*
   - Allows modules to reference vmlinux type IDs (for compression)

/Userspace/ BPF-prog ELF-object files also contains *BTF sections*
 - This is known as /local/ BTF and numbering starts at one
 - BPF-prog can query own local BTF id via: *=bpf_core_type_id_local()=*

* Slide: Q: Can we *identify* /BTF layout/ via the BTF ID?           :export:

Issue: BTF *type* /IDs/ are */not unique/* (32-bit)
 - But they are /unique within/ one *BTF object*

/BTF/ (objects) loaded into *kernel* also have an (BTF) *ID* (32-bit)
 - "vmlinux" gets ID 1
 - modules gets IDs assigned on loading
 - same for user loaded BTF objects

Construct /unique/: *Full* /BTF ID/ (64-bit)
 - via combining: BTF *object* and *type* ID


* Slide: End: /Questions?/                                         :noexport:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

* Emacs end-tricks                                                 :noexport:

This section contains some emacs tricks, that e.g. remove the "Slide:" prefix
in the compiled version.

# Local Variables:
# org-re-reveal-title-slide: "<h1 class=\"title\">%t</h1>
# <h2 class=\"author\">Jesper Dangaard Brouer<br/>
# <span style=\"font-size:75%%\">Sr. Principal Kernel Engineer, Red Hat</span></h2>
# <h3>Linux Plumbers Conference</br>September 2022</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: ?" "" contents)))
# End:
