# -*- fill-column: 79; -*-
#+TITLE: A practical introduction to XDP
#+AUTHOR: Jesper Dangaard Brouer and Andy Gospodarek
#+EMAIL: netoptimizer@brouer.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: './reveal.js/js/custom-xdp-tutorial.js'}
#+REVEAL_EXTRA_CSS: ./reveal.js/css/custom-xdp-tutorial.css
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: ./reveal.js/css/highlight/solarized-dark.css
# atom-one-dark.css
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

* Intro to document                                                :noexport:

This presentation will be given at Linux Plumbers Conference 2018,
main track.

 https://linuxplumbersconf.org/event/2/contributions/71/

This emacs org-mode document contains notes and slides for the
presentation. The slides are in reveal.js format and are generated by
exporting this document via ox-reveal emacs package.

Below sections with :export: tags are slides in the presentation.

* Export/generate presentation                                     :noexport:

** Setup for org export to reveal.js
First, install the ox-reveal emacs package.

Package: ox-reveal git-repo and install instructions:
https://github.com/yjwen/org-reveal

After this, move to the 'Topics and slides' subtree and hit =C-c C-e C-s R R=
to export just the subtree; then open .html file to view slideshow. The
variables at document end ("Local Variables") will set up the title slide and
filter the "Slide:" prefix from headings; Emacs will ask for permission to load
them, as they will execute code.

* Homepage abstract for presentation                               :noexport:

Speakers:
 - Jesper Dangaard Brouer (Red Hat)
 - Mr. Andy Gospodarek (Broadcom)

** Description:

The eXpress Data Path (XDP) has been gradually integrated into the
Linux kernel over several releases. XDP offers fast and programmable
packet processing in kernel context. The operating system kernel
itself provides a safe execution environment for custom packet
processing applications, in form of eBPF programs, executed in device
driver context. XDP provides a fully integrated solution working in
concert with the kernel's networking stack. Applications are written
in higher level languages such as C and compiled via LLVM into eBPF
bytecode which the kernel statically analyses for safety, and JIT
translates into native instructions. This is an alternative approach,
compared to kernel bypass mechanisms (like DPDK and netmap).

This talk gives a practical focused introduction to XDP. Describing
and giving code examples for the programming environment provided to
the XDP developer. The programmer need to change their mindeset a bit,
when coding for this XDP/eBPF execution environment. XDP programs are
often split between eBPF-code running kernel side and userspace
control plane. The control plane API not predefined, and is up to the
programmer, through userspace manipulating shared eBPF maps.


* Overall plan

Introdution to XDP
 - Single slide intro: What is XDP
 - XDP design goals

Basic building blocks
 - What are the basic building blocks?
 - Helpers
 - data vs control plane

Coding XDP programs
 - example code

Deep dive into the code behind XDP
 - What is required by XDP drivers?
   - RX napi_poll changes
   - Restrictions on memory model
   - New pluggable memory models per RX queue

How is this connected



* Below sections are presentation slides                           :noexport:

Section below with :export: tags are the slides.



* Slide: What will you learn?                                        :export:

* Introdution to XDP                                                 :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
Covering the basics of XDP first

** Slide: What is XDP?                                               :export:

#+BEGIN_NOTES
Be inspirational: New programmable layer in network stack.
#+END_NOTES

XDP basically: *New layer in the kernel network stack*
 - Before allocating the SKB
 - Driver level hook at DMA level

Means: Competing at the same “layer” as DPDK / netmap
 - Super fast, due to
   - Take action/decision earlier (e.g. skip some network layers)
   - No memory allocations

/Not kernel bypass/; data-plane is kept inside the kernel
 - Via eBPF: makes early network stack *run-time programmable*
 - Cooperates with the kernel stack

** XDP design goals                                                  :export:

XDP operate at same level L2/L3 level as kernel-bypass solutions (DPDK)
 - Network stack was build with socket-delivery use-case in focus (SKB)

XDP goals
 - /Close the performance gap/ to kernel-bypass solutions
   * *Not a goal to be faster*
 - Provide in-kernel alternative, that is *more flexible*
   * */Don’t steal the entire NIC/*
 - Work in concert with existing network stack


* Basic building blocks                                              :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
What are the basic XDP building block you can use?

** Slide: XDP actions and cooperation                                :export:

BPF program (in driver hook) return an action or verdict
 - XDP_ *DROP*, XDP_ *PASS*, XDP_ *TX*, XDP_ *ABORTED*, XDP_ *REDIRECT*

How to cooperate with network stack
 - /Pop/push/ or *modify* headers: Change RX-handler kernel use
   * e.g. handle protocol unknown to running kernel
 - Can propagate 32Bytes /meta-data/ from XDP stage to network stack
   * TC (clsbpf) hook can use meta-data, e.g. set SKB mark
 - Call /BPF helpers/

** Slide: Evolving XDP via BPF-helpers                               :export:

Think of XDP as /a software offload layer for the kernel network stack/
 - Setup and use Linux kernel network stack
 - But accelerate parts of it with XDP

IP routing good example:
 - Let Linux handle routing (daemons) and neighbour lookups
 - Access routing table from XDP via BPF /helper/: *bpf_fib_lookup*
 - This was covered in David Ahern's talk: [[http://vger.kernel.org/lpc-networking2018.html#session-1][Leveraging Kernel Tables with XDP]]

#+HTML: <p><br></p>
*Encourage adding helpers instead of duplicating data in BPF maps*


* Slide: XDP restricted-C code example : Drop UDP                    :export:

#+BEGIN_SRC C
SEC("xdp1") /* Marks first eBPF program section in ELF-binary */
int xdp_prog_drop_all_UDP(struct xdp_md *ctx) /* Name visible with bpftool */
{
	void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data;
	struct ethhdr *eth = data; u64 nh_off; u32 ipproto = 0;

	nh_off = sizeof(*eth); /* ETH_HLEN == 14 */
	if (data + nh_off > data_end) /* <-- Verifier use this boundry check */
		return XDP_ABORTED;

	if (eth->h_proto == htons(ETH_P_IP))
		ipproto = parse_ipv4(data, nh_off, data_end);
	if (ipproto == IPPROTO_UDP)
		return XDP_DROP;
	return XDP_PASS;
}
#+END_SRC

Simple XDP program that drop all IPv4 UDP packets
- Use /struct ethhdr/ to access /eth->h_proto/
- Helper for *parse_ipv4* (next slide)

* Slide: Simple helper to read iph->protocol                         :export:

#+BEGIN_SRC C
static __always_inline
int parse_ipv4(void *data, u64 nh_off, void *data_end)
{
	struct iphdr *iph = data + nh_off;

	/* Note + 1 on pointer advance one iphdr struct size */
	if (iph + 1 > data_end) /* <-- Again verifier check our boundry checks */
		return 0;
	return iph->protocol;
}
#+END_SRC

Simple helper *parse_ipv4* used in previous example
- Needs inlining as BPF bytes code doesn't have function calls
- Again remember boundry checks, else verifier reject program


* Slide: Driver XDP RX-handler (called by napi_poll)                 :export:

Extending a driver with XDP support:

#+BEGIN_SRC C
while (desc_in_rx_ring && budget_left--) {
	action = bpf_prog_run_xdp(xdp_prog, xdp_buff);
	/* helper bpf_redirect_map have set map (and index) via this_cpu_ptr */
	switch (action) {
	 case XDP_PASS:		break;
	 case XDP_TX:		res = driver_local_xmit_xdp_ring(adapter, xdp_buff); break;
	 case XDP_REDIRECT:	res = xdp_do_redirect(netdev, xdp_buff, xdp_prog);   break;
				/*via xdp_do_redirect_map() pickup map info from helper */
	 default:		bpf_warn_invalid_xdp_action(action);		/* fallthrough */
	 case XDP_ABORTED:	trace_xdp_exception(netdev, xdp_prog, action);  /* fallthrough */
	 case XDP_DROP:     res = DRV_XDP_CONSUMED; break;
	} /* left out acting on res */
}
/* End of napi_poll call do: */
xdp_do_flush_map(); /* Bulk size chosen by map, can store xdp_frame's for flushing */
driver_local_XDP_TX_flush();
#+END_SRC


* Slide: testing code example                                        :export:

#+BEGIN_SRC C
/* Must be called in process context */
void netif_napi_del(struct napi_struct *napi)
{
	might_sleep();
	if (napi_hash_del(napi))
		synchronize_net();
	list_del_init(&napi->dev_list);
	napi_free_frags(napi);

	flush_gro_hash(napi);
	napi->gro_bitmask = 0;
}

int i = 42;

if (i == 42)
	printf("universe");
/* Why do reveal.js in HTML export limit size of code-box? */
EXPORT_SYMBOL(netif_napi_del);
#+END_SRC

Bbla bla
- Bullet
- Anotherg bullet

* Org-mode hints                                                   :noexport:

https://orgmode.org/manual/Easy-templates.html#Easy-templates

#+BEGIN_EXAMPLE
<s TAB expands to a ‘src’ code block.

Others expansions:
<s	#+BEGIN_SRC ... #+END_SRC
<e	#+BEGIN_EXAMPLE ... #+END_EXAMPLE
<q	#+BEGIN_QUOTE ... #+END_QUOTE
<v	#+BEGIN_VERSE ... #+END_VERSE
<c	#+BEGIN_CENTER ... #+END_CENTER
<C	#+BEGIN_COMMENT ... #+END_COMMENT
#+END_EXAMPLE

* Emacs local variables                                            :noexport:

These emacs Local Variables does some export tricks.

# Local Variables:
# org-reveal-title-slide: "<h1 class=\"title\">%t</h1>
# <h2 class=\"author\">
# Jesper Dangaard Brouer (Red Hat)<br/>
# Andy Gospodarek (Broadcom)</h2>
# <h3>Linux Plumbers Conference (LPC)<br/>Vancouver, Nov 2018</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: " "" contents)))
# End:
