# -*- fill-column: 79; -*-
#+TITLE: A practical introduction to XDP
#+AUTHOR: Jesper Dangaard Brouer and Andy Gospodarek
#+EMAIL: netoptimizer@brouer.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: './reveal.js/js/custom-xdp-tutorial.js'}
#+REVEAL_EXTRA_CSS: ./reveal.js/css/custom-xdp-tutorial.css
#+REVEAL_PLUGINS: (highlight)
#+REVEAL_HIGHLIGHT_CSS: ./reveal.js/css/highlight/solarized-dark.css
# atom-one-dark.css
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

* Intro to document                                                :noexport:

This presentation will be given at Linux Plumbers Conference 2018,
main track.

 https://linuxplumbersconf.org/event/2/contributions/71/

This emacs org-mode document contains notes and slides for the
presentation. The slides are in reveal.js format and are generated by
exporting this document via ox-reveal emacs package.

Below sections with :export: tags are slides in the presentation.

* Export/generate presentation                                     :noexport:

** Setup for org export to reveal.js
First, install the ox-reveal emacs package.

Package: ox-reveal git-repo and install instructions:
https://github.com/yjwen/org-reveal

After this, move to the 'Topics and slides' subtree and hit =C-c C-e C-s R R=
to export just the subtree; then open .html file to view slideshow. The
variables at document end ("Local Variables") will set up the title slide and
filter the "Slide:" prefix from headings; Emacs will ask for permission to load
them, as they will execute code.

* Homepage abstract for presentation                               :noexport:

Speakers:
 - Jesper Dangaard Brouer (Red Hat)
 - Mr. Andy Gospodarek (Broadcom)

** Description:

The eXpress Data Path (XDP) has been gradually integrated into the
Linux kernel over several releases. XDP offers fast and programmable
packet processing in kernel context. The operating system kernel
itself provides a safe execution environment for custom packet
processing applications, in form of eBPF programs, executed in device
driver context. XDP provides a fully integrated solution working in
concert with the kernel's networking stack. Applications are written
in higher level languages such as C and compiled via LLVM into eBPF
bytecode which the kernel statically analyses for safety, and JIT
translates into native instructions. This is an alternative approach,
compared to kernel bypass mechanisms (like DPDK and netmap).

This talk gives a practical focused introduction to XDP. Describing
and giving code examples for the programming environment provided to
the XDP developer. The programmer need to change their mindeset a bit,
when coding for this XDP/eBPF execution environment. XDP programs are
often split between eBPF-code running kernel side and userspace
control plane. The control plane API not predefined, and is up to the
programmer, through userspace manipulating shared eBPF maps.


* Overall plan

Introduction to XDP
 - Single slide intro: What is XDP
 - XDP design goals

XDP building blocks
 - What are the building blocks?
 - Helpers

XDP relationship with eBPF
 - How is this connected
 - Design: Data vs control plane

Coding XDP programs
 - example code XDP
 - show maps usage?
 - userspace code reading map?

For NIC driver developer: Deep dive into the code behind XDP
 - What is required by XDP drivers?
   - RX napi_poll changes
   - Restrictions on memory model
   - New pluggable memory models per RX queue





* Below sections are presentation slides                           :noexport:

Section below with :export: tags are the slides.



* Slide: What will you learn?                                        :export:

* Introdution to XDP                                                 :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
Covering the basics of XDP first

** Slide: What is XDP?                                               :export:

#+BEGIN_NOTES
Be inspirational: New programmable layer in network stack.
#+END_NOTES

*New, programmable layer* in the kernel network stack
 - Native Mode XDP
   - Driver level hook available just after DMA of buffer descriptor
   - Process packets before SKB allocation /No waiting for memory allocation!/
 - SKB or Generic Mode XDP
   - Called from netif_receive_skb()
   - Driver independent, but more instructions needed for each packet

Run-time programmable packet processing inside the kernel *not kernel bypass*

Programs are compiled to platform-independent /eBPF bytecode/

Object files can be loaded on multiple kernels and architectures /without recompiling/

** XDP design goals                                                  :export:

XDP operate at same level L2/L3 level as kernel-bypass solutions (DPDK)
 - Network stack was build with socket-delivery use-case in focus (SKB)

XDP goals
 - /Close the performance gap/ to kernel-bypass solutions
   * *Not a goal to be faster*
 - Provide in-kernel alternative, that is *more flexible*
   * */Don’t steal the entire NIC/*
 - Work in concert with existing network stack without kernel modifications


* Basic building blocks                                              :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
What are the basic XDP building block you can use?

** Slide: XDP actions and cooperation                                :export:

BPF program (in driver hook) return an action or verdict
 - XDP_ *DROP*, XDP_ *PASS*, XDP_ *TX*, XDP_ *ABORTED*, XDP_ *REDIRECT*

How to cooperate with network stack
 - /Pop/push/ or *modify* headers: Change default rx_handler used by kernel 
   * e.g. handle on-wire protocol unknown to running kernel
 - Can propagate 32Bytes /meta-data/ from XDP stage to network stack
   * TC (clsbpf) hook can use meta-data, e.g. set SKB mark
   * Pre-parse packet contents (XDP Hints) and store in this area
 - Call /BPF helpers/ which are exported kernel functions
   * Helpers defined and documented in: */include/uapi/linux/bpf.h/*

** Slide: Evolving XDP via BPF helpers                               :export:

Think of XDP as /a software offload layer/ for the kernel network stack
 - Setup and use Linux kernel network stack
 - Accelerate parts of it with XDP

IP routing application is great example:
 - Let kernel manage route tables and perform neighbour lookups
 - Access routing table from XDP program via BPF /helper/: *bpf_fib_lookup*
 - Rewrite packet headers if next-hop found, otherwise send packet to kernel
 - This was covered in David Ahern's talk: [[http://vger.kernel.org/lpc-networking2018.html#session-1][Leveraging Kernel Tables with XDP]]

Similar concept could be extended to accelerate any kernel datapath

*Add helpers* instead of duplicating kernel data in BPF maps!

* Advanced building block                                            :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
XDP redirect is powerful

** Slide: XDP_REDIRECT action is special                             :export:

XDP *action* code /XDP_REDIRECT/ is flexible
 - In basic form: Redirecting RAW frames out another net_device/ifindex
   - *Egress device driver* needs to implement /ndo_xdp_xmit/
 - /Redirect into map/ gives flexibility to invent new destinations
   - And allow to *hide bulking* in bpf map code

Remember use helper: /bpf_redirect_map/ to activate bulking
 - Using helper: *bpf_redirect* gives you */worse performance/* than /bpf_redirect_map/

** Slide: Inventing redirect types via maps

The *devmap*: =BPF_MAP_TYPE_DEVMAP=
 - Contains /net_devices/, userspace adds them via ifindex to map-index

The *cpumap*: =BPF_MAP_TYPE_CPUMAP=
 - Allow redirecting RAW xdp_frame's to /remote CPU/
   - SKB is created on remote CPU, and normal network stack invoked
 - The map-index is the CPU number (the value is queue size)

*AF_XDP* - “xskmap”: =BPF_MAP_TYPE_XSKMAP=
 - Allow redirecting /RAW xdp frames into userspace/
   - via new Address Family socket type: AF_XDP


* XDP relationship with eBPF                                         :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
How is this connected?

** Design: XDP: data-plane and control-plane                         :export:

*Data-plane*: inside /kernel/, split into:
 - Kernel-core: Fabric in charge of moving packets quickly
 - In-kernel BPF program:
   * Policy logic decide action
   * Read/write access to packet

*Control-plane*: /Userspace/
 - Userspace load BPF program
 - Can control program via changing BPF maps
 - Everything goes through bpf system call


** Slide: XDP driver hook is executing eBPF byte-code

XDP put no restrictions on: How BPF byte-code is generated or loaded
 - XDP just get and attach BPF file-descriptor handle

BPF byte-code (and map-creation) all go-through bpf-syscall
 - You can provide hand-written BPF instructions (not practical)
 - Or use /LLVM+clang to generate BPF byte-code/
   - BCC compiles each time program runs
   - libbpf approach loads ELF-object created by LLVM/clang

** Slide: Code examples in this talk                                 :export:

This talk focus on: (approach as in kernel samples/bpf)
 - Writing *restricted-C* code in foo_kern.c
   * BPF code is restricted to protect kernel (not turing complete)
 - Compile to ELF object file foo_kern.o
 - Load via libbpf (kernel tools/lib/bpf) as XDP *data-plane*
 - Have *userspace control-plane* program foo_user.c via shared BPF-maps


* Coding XDP programs                                                :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
How do you code these XDP programs?
- Show me the code!!!

** Slide: XDP restricted-C code example : Drop UDP                   :export:

#+BEGIN_SRC C
SEC("xdp1") /* Marks first eBPF program section in ELF-binary */
int xdp_prog_drop_all_UDP(struct xdp_md *ctx) /* Name visible with bpftool */
{
	void *data_end = (void *)(long)ctx->data_end; void *data = (void *)(long)ctx->data;
	struct ethhdr *eth = data; u64 nh_off; u32 ipproto = 0;

	nh_off = sizeof(*eth); /* ETH_HLEN == 14 */
	if (data + nh_off > data_end) /* <-- Verifier use this boundry check */
		return XDP_ABORTED;

	if (eth->h_proto == htons(ETH_P_IP))
		ipproto = parse_ipv4(data, nh_off, data_end);
	if (ipproto == IPPROTO_UDP)
		return XDP_DROP;
	return XDP_PASS;
}
#+END_SRC

Simple XDP program that drop all IPv4 UDP packets
- Use /struct ethhdr/ to access /eth->h_proto/
- Function call for *parse_ipv4* (next slide)

** Slide: Simple function call to read iph->protocol                 :export:

#+BEGIN_SRC C
static __always_inline
int parse_ipv4(void *data, u64 nh_off, void *data_end)
{
	struct iphdr *iph = data + nh_off;

	/* Note + 1 on pointer advance one iphdr struct size */
	if (iph + 1 > data_end) /* <-- Again verifier check our boundry checks */
		return 0;
	return iph->protocol;
}
#+END_SRC

Simple function call /parse_ipv4/ used in previous example
- *Needs inlining* as BPF bytes code doesn't have function calls
- Again *remember boundry checks*, else verifier reject program

** Slide: libbpf: loading ELF-object code                       :export:

Userspace program must call BPF syscall to insert program info kernel

Luckily libbpf library written to help make this easier for developers
#+BEGIN_SRC C
struct bpf_object *obj;
int prof_fd;

struct bpf_prog_load_attr prog_load_attr = {
	.prog_type      = BPF_PROG_TYPE_XDP,
};

prog_load_addr.file = "xdp1_kern.o"

if (bpf_prog_load_xattr(&prog_load_attr, &obj, &prog_fd))
	return 1;

#+END_SRC
BPF bytecode and map definitions from xdp1_kern.o are now ready to use and
obj and prog_fd are set.

** Slide: libbpf: attaching XDP prog to ifindex                 :export:

Now that a program is loaded (remember prog_fd set in the last snippet shown), attach it to a netdev

#+BEGIN_SRC C
static int ifindex = 2;  /* in this case eth0 is ifindex 2 */
static __u32 xdp_flags = XDP_FLAGS_DRV_MODE /* or XDP_FLAGS_SKB_MODE */

if (bpf_set_link_xdp_fd(ifindex, prog_fd, xdp_flags) < 0) {
	printf("link set xdp fd failed\n");
	return 1;
}
#+END_SRC

If bpf_set_link_xdp_fd() is successful, the BPF program in xdp1_kern.o is attached to eth0
and program runs each time a packet arrives on that interface.

** Slide: Accessing eBPF map from within bpf program                       :export:

BPF maps are created when a program is loaded.  In this definition the map is an array, but there are a variety of types.

#+BEGIN_SRC C
struct bpf_map_def SEC("maps") rxcnt = {
        .type = BPF_MAP_TYPE_PERCPU_ARRAY,
        .key_size = sizeof(u32),
        .value_size = sizeof(long),
        .max_entries = 256,
};
#+END_SRC

While executing the program this map can be accessed like this:

#+BEGIN_SRC C
long *value;
u32 ipproto = 17;

value = bpf_map_lookup_elem(&rxcnt, &ipproto);
if (value)
	*value += 1;  /* We saw a UDP frame! */
#+END_SRC

** Slide: Accessing eBPF map from user space                       :export:

Since BPF maps can bee used to communicate information (statistics in this example)
between the BPF program easily.  First locate the map:

#+BEGIN_SRC C
map = bpf_map__next(NULL, obj);
if (!map) {
	printf("finding a map in obj file failed\n");
	return 1;
}
map_fd = bpf_map__fd(map);
#+END_SRC

Now the map contents can be accessed like this:
#+BEGIN_SRC C
__u32 key = 17;
__u64 value;

if (bpf_map_lookup_elem(map_fd, &key, &value))
	return 1;

printf("key %u value %llu\n", key, value);
#+END_SRC

* For NIC driver developer
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:
Deep dive into the code behind XDP
- and driver level requirements

** Slide: Driver XDP RX-handler (called by napi_poll)                :export:

Extending a driver with XDP support:

#+BEGIN_SRC C
while (desc_in_rx_ring && budget_left--) {
	action = bpf_prog_run_xdp(xdp_prog, xdp_buff);
	/* helper bpf_redirect_map have set map (and index) via this_cpu_ptr */
	switch (action) {
	 case XDP_PASS:		break;
	 case XDP_TX:		res = driver_local_xmit_xdp_ring(adapter, xdp_buff); break;
	 case XDP_REDIRECT:	res = xdp_do_redirect(netdev, xdp_buff, xdp_prog);   break;
				/*via xdp_do_redirect_map() pickup map info from helper */
	 default:		bpf_warn_invalid_xdp_action(action);		/* fallthrough */
	 case XDP_ABORTED:	trace_xdp_exception(netdev, xdp_prog, action);  /* fallthrough */
	 case XDP_DROP:     res = DRV_XDP_CONSUMED; break;
	} /* left out acting on res */
}
/* End of napi_poll call do: */
xdp_do_flush_map(); /* Bulk size chosen by map, can store xdp_frame's for flushing */
driver_local_XDP_TX_flush();
#+END_SRC

Bulk via: helper *bpf_redirect_map* + /xdp_do_redirect/ + /xdp_do_flush_map/

** Slide: Restrictions on driver memory model                        :export:

XDP put certain restrictions on RX memory model
 - The one page per RX-frame: */No longer true/*
 - Requirement: RX-frame memory must be in /continues in physical memory/
   - Needed to support eBPF Direct-Access to memory validation
 - (Currently) Also require tail-room for SKB shared-info section
   - for SKB alloc outside driver, fits well with driver using build_skb() API

*Not supported*: drivers that split frame into several memory areas
 - This usually result in disabling Jumbo-Frame, when loading XDP prog
 - XDP have forced driver to support several RX-memory models
   - This was part of the (evil?) master-plan...

** Slide: New pluggable memory models per RX queue                   :export:

Recent change: Memory return API
 - API for how XDP_REDIRECT'ed frames are freed or "returned"
   - XDP frames are /returned to originating RX driver/
 - Furthermore: this happens per RX-queue level (extended xdp_rxq_info)

This allows driver to implement *different memory models per RX-queue*
 - E.g. needed for AF_XDP /zero-copy mode/

Also /opportunity to share/ common RX-allocator code between drivers
 - page_pool is an example, need more drivers using it

* End                                                                :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

Thanks to all contributors
 - XDP + BPF /combined effort/ of *many* people

* Org-mode hints                                                   :noexport:

https://orgmode.org/manual/Easy-templates.html#Easy-templates

#+BEGIN_EXAMPLE
<s TAB expands to a ‘src’ code block.

Others expansions:
<s	#+BEGIN_SRC ... #+END_SRC
<e	#+BEGIN_EXAMPLE ... #+END_EXAMPLE
<q	#+BEGIN_QUOTE ... #+END_QUOTE
<v	#+BEGIN_VERSE ... #+END_VERSE
<c	#+BEGIN_CENTER ... #+END_CENTER
<C	#+BEGIN_COMMENT ... #+END_COMMENT
#+END_EXAMPLE

* Emacs local variables                                            :noexport:

These emacs Local Variables does some export tricks.

# Local Variables:
# org-reveal-title-slide: "<h1 class=\"title\">%t</h1>
# <h2 class=\"author\">
# Jesper Dangaard Brouer (Red Hat)<br/>
# Andy Gospodarek (Broadcom)</h2>
# <h3>Linux Plumbers Conference (LPC)<br/>Vancouver, Nov 2018</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: " "" contents)))
# End:
