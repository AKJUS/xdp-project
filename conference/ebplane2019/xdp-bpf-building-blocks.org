# -*- fill-column: 79; -*-
#+TITLE: Introduction to: XDP and BPF building blocks
#+AUTHOR: Jesper Dangaard Brouer <brouer@redhat.com>
#+EMAIL: brouer@redhat.com
#+REVEAL_THEME: redhat
#+REVEAL_TRANS: linear
#+REVEAL_MARGIN: 0
#+REVEAL_EXTRA_JS: { src: '../reveal.js/js/redhat.js'}
#+REVEAL_ROOT: ../reveal.js
#+OPTIONS: reveal_center:nil reveal_control:t reveal_history:nil
#+OPTIONS: reveal_width:1600 reveal_height:900
#+OPTIONS: ^:nil tags:nil toc:nil num:nil ':t

* For conference: ebplane 2019                                     :noexport:

This presentation will be given at Junipers HQ in Sunnyvale, Oct 21st 2019.

** Abstract

The ebplane project is in an early startup phase. Thus, use-cases and what the
technology is planned to be used for exactly, are still not well defined.

The ebplane project have a clear interest in leveraging eBPF technology within
computer networking area. The two most successfully eBPF networking hooks in
the Linux kernel are XDP (eXpress Data Path) and TC-BPF (Traffic Control).

This presentation serves as an introduction to the BPF network technologies,
with a focus on XDP and TC. Given the lack of clear use-cases, the presentation
will generalise and introduce the technology in form of describing the building
blocks available.

Understanding the building blocks and their limitations are actually essential
for the success of the project. As it requires thinking differently when
developing an "application" with BPF. The key insight is that you are not
developing a new "application" e.g. data plane from scratch. Instead you are
modifying the behaviour of an existing system (the Linux kernel), to do what
you want, via injecting code snippets at different hooks, that are only event
based. The BPF code snippets are by default stateless, but can obtain state and
change runtime behaviour via BPF-maps.

Q: How can we talk about gaps, when use-cases are undefined?

The BPF+XDP technology are under active development, which is both good and
bad. The bad news is that there are likely gaps for e.g. developing a data
plane. But the good news is that we can address these gaps, given upstream
kernel maintainers are participating. The presentation will cover some of these
gaps, and explain how BPF can be extended. With a little clever thinking, some
of these gaps can be addressed by doing fall-back to kernel network stack, for
slow(er) code-path handling.

If timer permits, we will also present some of the planned extensions to XDP
and BPF.

Q: Should we have close to the "code" section? Where we e.g. describe some of
the fundamental data structures?

** Agenda planning

https://pad.sfconservancy.org/p/ebplane-20191021-agenda

** Other material

Juniper slides:
https://docs.google.com/presentation/d/1JHrl8PlLyVRSMvtF8OUa3BW3GcRf4a3Kx2CPw2g7tJg/edit?ts=5d542a23#slide=id.p


* Colors in slides                                                 :noexport:
Text colors on slides are chosen via org-mode italic/bold high-lighting:
 - /italic/ = /green/
 - *bold*   = *yellow*
 - */italic-bold/* = red

* Slides below                                                     :noexport:

Only sections with tag ":export:" will end-up in the presentation. The prefix
"Slide:" is only syntax-sugar for the reader (and it removed before export by
emacs).

* Slide: Overview: What will you learn?                            :noexport:

EMPTY SLIDE
- Need to "finish" slide-deck before doing overview slide

* Slide: The 'ebplane' project                                       :export:

The ebplane project: *early startup phase*
- Initial presentation title: [[https://docs.google.com/presentation/d/1JHrl8PlLyVRSMvtF8OUa3BW3GcRf4a3Kx2CPw2g7tJg/edit?ts=5d542a23#slide=id.p]["Universal Data Plane Proposal"]]
  - Show interest in /leveraging eBPF technology for networking/
- /*Yet to be defined*/: use-cases and network-layers to target

This presentation: /eBPF technology level setting/
- /Building blocks/ and their *limitations*
- Designing with eBPF requires slightly different thinking...
  - essential for success of this project

** Slide: Different design thinking: High level overview            :export:

*/Wrong thinking/*: Designing new data plane *from scratch*

Key insight#1: /Modifying behaviour of existing system/ (Linux kernel)
- Via injecting /code snippets/ at different *hooks*
- BPF code snippets are *event-based* and by default stateless
- Obtain state and change runtime behaviour via shared BPF-*maps*

Key insight#2: /Only load code when actually needed/
- The fastest code is code that doesn't run (or even loaded)
- Design system to *only load code relevant to user* configured use-case
- E.g. don't implement generic parser to handle every know protocol
  - instead create parser specific to users need/config

* Slide: Basic introduction and understanding of eBPF                :export:
:PROPERTIES:
:reveal_extra_attr: class="mid-slide"
:END:

*Technical:* /Level setting slides for eBPF technology/

Basic introduction and understanding of BPF
- eBPF bytecode
- Compiling restricted-C to eBPF
  * compiler storing it in ELF-format
  * loading this into the Linux kernel


** Slide: eBPF bytecode and kernel hooks                            :export:

XDP 'just' one Linux kernel hook that can run eBPF-bytecode
- Many more eBPF hooks (tracepoint, all function calls via kprobe)

The eBPF bytecode is:
- /Generic Instruction Set/ Architecture (ISA) with C-calling convention
  * Read: the eBPF assembly language
- Designed to *run in the Linux kernel*
  * It is */not a kernel module/*
  * It is a *sandbox* technology; BPF verfier ensures code safety
  * Kernel provides an /eBPF runtime/ environment, via BPF /helper calls/

** Slide: Compiling restricted-C to eBPF into ELF                   :export:

/LLVM compiler/ has an eBPF backend (to */avoid writing eBPF assembly/* by hand)
- Write *Restricted C* -- some limits imposed by sandbox BPF-verfier

Compiler produces an standard ELF "executable" file
- Cannot execute this file directly, as the eBPF runtime is inside the kernel
- Need our *own ELF loader* that can:
  * Extract the eBPF bytecode and eBPF maps
  * Do ELF relocation of eBPF maps references in bytecode
  * Create/load eBPF maps and bytecode into kernel
- *Attaching to hook is separate* step

** Slide: Recommend using libbpf                                    :export:

Recommend using /libbpf/ as the *ELF loader for eBPF*
- libbpf is /part of Linux kernel tree/
- Facebook fortunately *exports* this to https://github.com/libbpf
  * XDP-tutorial git repo, use [[https://github.com/libbpf/libbpf][libbpf]] as git-submodule

Please userspace apps: *Everybody should use this library*
- */Unfortunately/* several loaders exists
- Worst case is iproute2 have its own
  * cause incompatible ELF object, if using eBPF maps
  * (plans for converting to libbpf)

** Slide: eBPF concepts: context, maps and helpers

Each eBPF runtime event hook gets a *pointer to a context* struct
- BPF bytecode has access to context (read/write limited)
  * verifier may adjust the bytecode for safety

The BPF program itself is stateless
- /Concept eBPF maps/ can be used to create state, and "config"
- Maps are basically /key = value/ construct

BPF helpers are used for
- calling kernel functions, to obtain info/state from kernel

* Emacs end-tricks                                                 :noexport:

# Local Variables:
# org-re-reveal-title-slide: "<h1 class=\"title\">%t</h1><h2
# class=\"author\">Jesper Dangaard Brouer<br/>Kernel Developer<br/>Red Hat</h2>
# <h3>ebplane hosted by Juniper<br/>USA, Sunnyvale, Oct 2019</h3>"
# org-export-filter-headline-functions: ((lambda (contents backend info) (replace-regexp-in-string "Slide: " "" contents)))
# End:
